import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.-kPtTt-D.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"Queen MQ","text":"Modern PostgreSQL-backed Message Queue","tagline":"High-performance, feature-rich message queue system with unlimited FIFO partitions, consumer groups, transactions, and streaming capabilities","image":{"src":"/queen-logo.svg","alt":"Queen MQ Logo"},"actions":[{"theme":"brand","text":"Get Started","link":"/guide/quickstart"},{"theme":"alt","text":"View on GitHub","link":"https://github.com/smartpricing/queen"},{"theme":"alt","text":"Docker Hub","link":"https://hub.docker.com/r/smartnessai/queen-mq"}]},"features":[{"icon":"ğŸš€","title":"High Performance","details":"Handle 200K+ messages/sec with proper batching. Built with C++17, uWebSockets, and async PostgreSQL for minimal latency.","link":"/server/benchmarks"},{"icon":"ğŸ¯","title":"Unlimited FIFO Partitions","details":"Create as many ordered partitions as you need. Messages in each partition are guaranteed to be processed in order with automatic lock management.","link":"/guide/queues-partitions"},{"icon":"ğŸ‘¥","title":"Consumer Groups","details":"Kafka-style consumer groups with independent position tracking. Process the same messages for different purposes with replay from any timestamp.","link":"/guide/consumer-groups"},{"icon":"ğŸ”„","title":"Transactions","details":"Atomic operations across queues with exactly-once delivery guarantees. Chain push and ack operations to build reliable workflows.","link":"/guide/transactions"},{"icon":"ğŸ“¡","title":"Streaming","details":"Real-time message streaming. Build aggregation pipelines and process messages as they arrive.","link":"/guide/streaming"},{"icon":"â±ï¸","title":"Long Polling","details":"Efficient server-side waiting for messages. No busy loops, no wasted resources. Messages delivered instantly when available.","link":"/guide/long-polling"},{"icon":"ğŸ›¡ï¸","title":"Zero Message Loss","details":"Automatic failover to disk when PostgreSQL is unavailable. Automatic replay when database recovers. Survives crashes and restarts.","link":"/guide/failover"},{"icon":"ğŸ’€","title":"Dead Letter Queue","details":"Automatic handling of failed messages. Configurable retry limits and DLQ routing. Debug and replay failed messages easily.","link":"/guide/dlq"},{"icon":"ğŸ”","title":"Message Encryption","details":"Optional at-rest encryption at the database level. Secure your sensitive messages with per-queue encryption configuration.","link":"/guide/queues-partitions"},{"icon":"ğŸ“Š","title":"Beautiful Dashboard","details":"Modern Vue 3 web interface with real-time metrics, message browser, trace explorer, and analytics. Monitor everything in one place.","link":"/webapp/overview"},{"icon":"ğŸ”","title":"Message Tracing","details":"End-to-end tracing across queues and workflows. Debug complex distributed systems with visual trace timelines.","link":"/guide/tracing"},{"icon":"ğŸŒ","title":"Multi-Language Clients","details":"JavaScript and C++ clients with idiomatic APIs. Or use the HTTP API directly from any language. Python client coming soon.","link":"/clients/javascript"}]},"headers":[],"relativePath":"index.md","filePath":"index.md"}'),n={name:"index.md"};function r(l,s,p,h,o,k){return e(),a("div",null,[...s[0]||(s[0]=[t("",45)])])}const u=i(n,[["render",r]]);export{c as __pageData,u as default};
