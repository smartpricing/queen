import{_ as i,c as a,o as e,ag as n}from"./chunks/framework.-kPtTt-D.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"Queen MQ","text":"Modern PostgreSQL-backed Message Queue","tagline":"High-performance, feature-rich message queue system with unlimited FIFO partitions, consumer groups, and transactions","image":{"src":"/queen_logo.png","alt":"Queen MQ Logo"},"actions":[{"theme":"brand","text":"Get Started","link":"/guide/quickstart"},{"theme":"alt","text":"View on GitHub","link":"https://github.com/smartpricing/queen"},{"theme":"alt","text":"Docker Hub","link":"https://hub.docker.com/r/smartnessai/queen-mq"}]},"features":[{"title":"High Performance","details":"Handle 200K+ messages/sec with proper batching. Built with C++17, uWebSockets, and async PostgreSQL for minimal latency.","link":"/server/benchmark-results"},{"title":"Unlimited FIFO Partitions","details":"Create as many ordered partitions as you need. Messages in each partition are guaranteed to be processed in order with automatic lock management.","link":"/guide/queues-partitions"},{"title":"Consumer Groups","details":"Kafka-style consumer groups with independent position tracking. Process the same messages for different purposes with replay from any timestamp.","link":"/guide/consumer-groups"},{"title":"Transactions","details":"Atomic operations across queues with exactly-once delivery guarantees. Chain push and ack operations to build reliable workflows.","link":"/guide/transactions"},{"title":"Long Polling","details":"Efficient server-side waiting for messages. No busy loops, no wasted resources. Messages delivered instantly when available.","link":"/guide/long-polling"},{"title":"Zero Message Loss","details":"Automatic failover to disk when PostgreSQL is unavailable. Automatic replay when database recovers. Survives crashes and restarts.","link":"/guide/failover"},{"title":"Dead Letter Queue","details":"Automatic handling of failed messages. Configurable retry limits and DLQ routing. Debug and replay failed messages easily.","link":"/guide/dlq"},{"title":"Message Encryption","details":"Optional at-rest encryption at the database level. Secure your sensitive messages with per-queue encryption configuration.","link":"/guide/queues-partitions"},{"title":"Beautiful Dashboard","details":"Modern Vue 3 web interface with real-time metrics, message browser, trace explorer, and analytics. Monitor everything in one place.","link":"/webapp/overview"},{"title":"Message Tracing","details":"End-to-end tracing across queues and workflows. Debug complex distributed systems with visual trace timelines.","link":"/guide/tracing"},{"title":"Multi-Language Clients","details":"JavaScript, Python, and C++ clients with idiomatic APIs. Or use the HTTP API directly from any language.","link":"/clients/javascript"},{"title":"Distributed Cache (UDPSYNC)","details":"Multi-server deployments share state via UDP sync to reduce database queries by 80-90%. Real-time peer notifications for instant message delivery.","link":"/server/deployment#distributed-cache-udpsync"}]},"headers":[],"relativePath":"index.md","filePath":"index.md"}'),t={name:"index.md"};function l(r,s,p,h,k,d){return e(),a("div",null,[...s[0]||(s[0]=[n("",47)])])}const u=i(t,[["render",l]]);export{c as __pageData,u as default};
