import{_ as a,c as t,o as i,ag as r}from"./chunks/framework.-kPtTt-D.js";const g=JSON.parse('{"title":"Introduction to Queen MQ","description":"","frontmatter":{},"headers":[],"relativePath":"guide/introduction.md","filePath":"guide/introduction.md"}'),s={name:"guide/introduction.md"};function n(o,e,l,u,c,h){return i(),t("div",null,[...e[0]||(e[0]=[r('<h1 id="introduction-to-queen-mq" tabindex="-1">Introduction to Queen MQ <a class="header-anchor" href="#introduction-to-queen-mq" aria-label="Permalink to &quot;Introduction to Queen MQ&quot;">​</a></h1><p>Queen MQ is a modern, PostgreSQL-backed message queue system designed for high performance, reliability, and developer happiness. Born from the need to manage many FIFO partitions for <a href="https://www.linkedin.com/company/smartness-com/" target="_blank" rel="noreferrer">Smartchat</a> with solid guarantees around delivery and failure handling.</p><h2 id="what-is-queen-mq" tabindex="-1">What is Queen MQ? <a class="header-anchor" href="#what-is-queen-mq" aria-label="Permalink to &quot;What is Queen MQ?&quot;">​</a></h2><p>Queen is a message queue system written in C++ that leverages PostgreSQL&#39;s reliability and ACID guarantees. It combines the best features from existing message queue systems like RabbitMQ, Kafka, and NATS into a unified, powerful platform.</p><div class="info custom-block"><p class="custom-block-title">Why &quot;Queen&quot;?</p><p>Years ago, when the creator first read the word &quot;queue&quot;, they read it as &quot;queen&quot; in their mind. The name stuck!</p></div><h2 id="key-features" tabindex="-1">Key Features <a class="header-anchor" href="#key-features" aria-label="Permalink to &quot;Key Features&quot;">​</a></h2><h3 id="unlimited-fifo-partitions" tabindex="-1">Unlimited FIFO Partitions <a class="header-anchor" href="#unlimited-fifo-partitions" aria-label="Permalink to &quot;Unlimited FIFO Partitions&quot;">​</a></h3><p>Create as many ordered partitions as you need within each queue. Messages in the same partition are guaranteed to be processed in order, with automatic lock management to ensure only one consumer processes a partition at a time.</p><h3 id="consumer-groups" tabindex="-1">Consumer Groups <a class="header-anchor" href="#consumer-groups" aria-label="Permalink to &quot;Consumer Groups&quot;">​</a></h3><p>Kafka-style consumer groups allow multiple groups to process the same messages independently. Each group tracks its own position and can start from the beginning, from a specific timestamp, or only process new messages.</p><h3 id="transactions" tabindex="-1">Transactions <a class="header-anchor" href="#transactions" aria-label="Permalink to &quot;Transactions&quot;">​</a></h3><p>Atomic operations across queues with exactly-once delivery guarantees. Chain push and ack operations together to build reliable workflows that never lose or duplicate messages.</p><h3 id="long-polling" tabindex="-1">Long Polling <a class="header-anchor" href="#long-polling" aria-label="Permalink to &quot;Long Polling&quot;">​</a></h3><p>Efficient server-side waiting for messages. No busy loops, no wasted resources. Messages are delivered instantly when they become available.</p><h3 id="zero-message-loss" tabindex="-1">Zero Message Loss <a class="header-anchor" href="#zero-message-loss" aria-label="Permalink to &quot;Zero Message Loss&quot;">​</a></h3><p>Automatic failover to disk when PostgreSQL is unavailable. Messages are buffered locally and automatically replayed when the database recovers. Survives crashes and restarts.</p><h3 id="dead-letter-queue" tabindex="-1">Dead Letter Queue <a class="header-anchor" href="#dead-letter-queue" aria-label="Permalink to &quot;Dead Letter Queue&quot;">​</a></h3><p>Automatic handling of failed messages. Configure retry limits and have messages automatically routed to the dead letter queue for debugging and manual intervention.</p><h2 id="architecture-highlights" tabindex="-1">Architecture Highlights <a class="header-anchor" href="#architecture-highlights" aria-label="Permalink to &quot;Architecture Highlights&quot;">​</a></h2><ul><li><strong>High Performance</strong>: Handle 10k req/s with houndreds of thousands of messages/second</li><li><strong>C++17</strong>: Modern C++ with uWebSockets and libuv</li><li><strong>Async PostgreSQL</strong>: Fully asynchronous, non-blocking database operations thoughout libuv</li><li><strong>Horizontal Scaling</strong>: Multiple server instances for HA</li><li><strong>Modern Dashboard</strong>: Beautiful Vue 3 web interface for monitoring and management</li></ul><h2 id="use-cases" tabindex="-1">Use Cases <a class="header-anchor" href="#use-cases" aria-label="Permalink to &quot;Use Cases&quot;">​</a></h2><h3 id="enterprise-workflows" tabindex="-1">Enterprise Workflows <a class="header-anchor" href="#enterprise-workflows" aria-label="Permalink to &quot;Enterprise Workflows&quot;">​</a></h3><p>Build multi-step workflows with transactional guarantees:</p><ul><li>Order processing pipelines</li><li>Financial transaction systems</li><li>Data transformation pipelines</li><li>Multi-stage approval processes</li></ul><h3 id="real-time-analytics" tabindex="-1">Real-time Analytics <a class="header-anchor" href="#real-time-analytics" aria-label="Permalink to &quot;Real-time Analytics&quot;">​</a></h3><p>Send messages to multiple consumer groups for different purposes:</p><ul><li>Real-time metrics aggregation</li><li>Business intelligence dashboards</li><li>Log aggregation and analysis</li><li>Event monitoring</li></ul><h3 id="event-driven-architecture" tabindex="-1">Event-Driven Architecture <a class="header-anchor" href="#event-driven-architecture" aria-label="Permalink to &quot;Event-Driven Architecture&quot;">​</a></h3><p>Decouple microservices with guaranteed message delivery:</p><ul><li>Service-to-service communication</li><li>Event sourcing</li><li>CQRS patterns</li><li>Saga orchestration</li></ul><h3 id="task-queues" tabindex="-1">Task Queues <a class="header-anchor" href="#task-queues" aria-label="Permalink to &quot;Task Queues&quot;">​</a></h3><p>Distribute work across multiple workers:</p><ul><li>Background job processing</li><li>Video transcoding</li><li>Report generation</li><li>Email delivery</li></ul><h2 id="design-principles" tabindex="-1">Design Principles <a class="header-anchor" href="#design-principles" aria-label="Permalink to &quot;Design Principles&quot;">​</a></h2><ol><li><strong>Developer First</strong>: Simple, intuitive APIs that make complex workflows easy</li><li><strong>Performance</strong>: Built for speed with async I/O and minimal overhead</li><li><strong>Reliability</strong>: ACID guarantees, automatic failover, zero message loss</li><li><strong>Flexibility</strong>: Support multiple messaging patterns (queue, pub/sub)</li><li><strong>Observability</strong>: Built-in tracing, metrics, and beautiful dashboard</li></ol><h2 id="getting-started" tabindex="-1">Getting Started <a class="header-anchor" href="#getting-started" aria-label="Permalink to &quot;Getting Started&quot;">​</a></h2><p>Ready to dive in? Check out the <a href="/queen/guide/quickstart.html">Quick Start Guide</a> to get Queen MQ running in minutes.</p><p>Or explore specific topics:</p><ul><li><a href="/queen/guide/concepts.html">Basic Concepts</a> - Understand queues, partitions, and consumer groups</li><li><a href="/queen/clients/javascript.html">JavaScript Client</a> - Start building with the JS client</li><li><a href="/queen/clients/python.html">Python Client</a> - Start building with the Python client</li><li><a href="/queen/clients/cpp.html">C++ Client</a> - High-performance C++ client</li><li><a href="/queen/server/installation.html">Server Setup</a> - Install and configure the server</li><li><a href="/queen/clients/examples/basic.html">Examples</a> - See real-world usage patterns</li></ul>',39)])])}const m=a(s,[["render",n]]);export{g as __pageData,m as default};
