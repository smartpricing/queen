# Async Experiment Patch for Push Route
# This is a proof-of-concept to test Loop::defer with std::thread

--- a/server/src/acceptor_server.cpp
+++ b/server/src/acceptor_server.cpp
@@ -485,6 +485,50 @@ static void setup_worker_routes(uWS::App* app,
         );
     });
     
+    // EXPERIMENTAL: Async Push Route using std::thread + Loop::defer
+    app->post("/api/v1/push-async-experiment", [queue_manager, file_buffer, worker_id](auto* res, auto* req) {
+        read_json_body(res,
+            [res, queue_manager, file_buffer, worker_id](const nlohmann::json& body) {
+                try {
+                    spdlog::info("[Worker {}] ASYNC EXPERIMENT: Starting async push", worker_id);
+                    
+                    // Get the current uWebSockets loop
+                    uWS::Loop* current_loop = uWS::Loop::get();
+                    
+                    // Launch work in separate thread
+                    std::thread async_worker([res, queue_manager, file_buffer, worker_id, current_loop, body]() {
+                        spdlog::info("[Worker {}] ASYNC EXPERIMENT: Running in separate thread", worker_id);
+                        
+                        try {
+                            // Simulate the current push logic (this will block, but in separate thread)
+                            std::vector<PushItem> items;
+                            for (const auto& item_json : body["items"]) {
+                                PushItem item;
+                                item.queue = item_json["queue"];
+                                item.partition = item_json.value("partition", "Default");
+                                item.payload = item_json.value("payload", nlohmann::json{});
+                                if (item_json.contains("transactionId")) {
+                                    item.transaction_id = item_json["transactionId"];
+                                }
+                                items.push_back(std::move(item));
+                            }
+                            
+                            // This blocks, but we're in a separate thread now!
+                            auto results = queue_manager->push_messages(items);
+                            
+                            // Use Loop::defer to safely send response back to uWebSockets thread
+                            current_loop->defer([res, results, worker_id]() {
+                                spdlog::info("[Worker {}] ASYNC EXPERIMENT: Sending response via Loop::defer", worker_id);
+                                send_json_response(res, nlohmann::json(results), 201);
+                            });
+                            
+                        } catch (const std::exception& e) {
+                            // Error handling - also use Loop::defer
+                            current_loop->defer([res, error = std::string(e.what()), worker_id]() {
+                                spdlog::error("[Worker {}] ASYNC EXPERIMENT: Error via Loop::defer: {}", worker_id, error);
+                                send_error_response(res, error, 500);
+                            });
+                        }
+                    });
+                    
+                    // Detach the thread so it runs independently
+                    async_worker.detach();
+                    
+                    spdlog::info("[Worker {}] ASYNC EXPERIMENT: Main thread continues immediately", worker_id);
+                    
+                } catch (const std::exception& e) {
+                    send_error_response(res, e.what(), 500);
+                }
+            },
+            [res](const std::string& error) {
+                send_error_response(res, error, 400);
+            }
+        );
+    });
+    
     // Push messages
     app->post("/api/v1/push", [queue_manager, file_buffer, worker_id](auto* res, auto* req) {
         read_json_body(res,
